# Demo Enrichment — Execution Prompt

Paste everything below the line into a new Claude Code session.

---

## Task

Execute the implementation plan at `docs/plans/2026-02-27-demo-enrichment-plan.md` task-by-task. The design rationale is in `docs/plans/2026-02-27-demo-enrichment-design.md`.

Use the `superpowers:executing-plans` skill.

## What this plan does

Enriches the four CLI demos (trust, match, trace, capability) to serve as executable protocol documentation for developers. Two prerequisite tasks update core modules first, then four tasks update the demos.

**Task order is sequential — each depends on the previous:**

- **Task 0**: Add Newcomer tier to trust module (core change, 9 locations in tiers.ts + exposure.ts + vouching.ts + schema)
- **Task 1**: Enrich core scorer with 3 new scoring dimensions (surplus sensitivity, diversity, sector)
- **Task 2**: Enrich example JSON data (participants, offerings, needs)
- **Task 3**: Update match demo to use core scorer via data adapter
- **Task 4**: Enrich trust demo with 4-tier model and 6 personas
- **Task 5**: Rewrite trace demo with protocol messages and 3 scenarios
- **Task 6**: Add offline capability demo
- **Task 7**: Final verification

## Key things the implementer must know

### Architecture decisions

1. **Core modules are updated, not just demos.** Task 0 adds Newcomer to the trust module proper. Task 1 adds scoring dimensions to the core scorer. Demos then consume updated modules.
2. **Demo uses core scorer via thin adapter.** The match demo replaces its inline `simpleMatchScore` with the real `scoreMatch` function, using adapter functions to transform JSON data format → scorer interfaces.
3. **Trace demo protocol messages are illustrative.** The state machine doesn't support counter-proposals or stuck flags natively. The trace demo narrates these and labels messages as "illustrative — they demonstrate the message structures defined in the protocol-messages schema, not generated by a production protocol layer."

### Risks mitigated in the plan

These were identified during critical evaluation and mitigations are already baked into the plan steps:

1. **Scorer weights are specified concretely** (Task 1, Step 7) — trust/geographic are deal-breakers (binary 0/1), remaining 6 dimensions are weighted: semantic 0.30, timing 0.15, capacity 0.10, surplus 0.15, diversity 0.15, sector 0.15.
2. **Example data has requirements checklist** (Task 2) — 6 specific scenarios the data must support (geographic filter, time sensitivity alignment, etc.).
3. **Adapter verification step** (Task 3, Step 0) — read enriched data and verify field paths before writing adapter code.
4. **Trace output budget** (Task 5) — 30-50 lines per scenario, 4-6 fields per protocol message.
5. **Smoke-test after data enrichment** (Task 2, Step 6b) — run match demo to verify enriched data loads.
6. **assessTier default updated** (Task 0, Step 6) — changed from 'probationary' to 'newcomer'.
7. **calculateProgress needs no changes** — arithmetic handles Newcomer→Probationary correctly.

### Watch out for

- **`VouchingConfig` interface** (vouching.ts:106-110): Has hardcoded tier keys in the TypeScript interface type, not just the config object. Plan Step 8 covers both.
- **`validateLimitsConfiguration`** (exposure.ts:310): Has a hardcoded tier array. Plan Step 7 covers this.
- **Example data is already partially enriched.** `surplus_context`, `urgency`, `constraints.geographic` already exist on some entries. Extend/adjust, don't duplicate.
- **British English throughout.** Colour, organisation, behaviour, fulfilment.
- **Box-drawing characters** for demo output headers (═, ─, etc.) — consistent across all demos.

## How to use sub-agents

You can use sub-agents for:

- **Parallel file reading** at the start of each task (read the files to modify + the plan task description)
- **Validation runs** after each task (build, validate schemas, run demos)
- **Code review** after completing each task before committing

Do NOT parallelise the tasks themselves — they're sequential dependencies.

## Key file reference

| File | Role |
|------|------|
| `docs/plans/2026-02-27-demo-enrichment-plan.md` | **The plan — authoritative, follow exactly** |
| `docs/plans/2026-02-27-demo-enrichment-design.md` | Design rationale (consult if "why" is unclear) |
| `src/trust/tiers.ts` | Trust tier system — Task 0 primary target |
| `src/trust/exposure.ts` | Exposure limits — Task 0 |
| `src/trust/vouching.ts` | Vouching system — Task 0 |
| `src/matching/scorer.ts` | Core scorer — Task 1 primary target |
| `examples/matching/*.json` | Example data — Task 2 |
| `src/examples/match-demo.ts` | Match demo — Task 3 |
| `src/examples/trust-demo.ts` | Trust demo — Task 4 |
| `src/examples/trace-chain.ts` | Trace demo — Task 5 |
| `src/examples/capability-demo.ts` | Capability demo (live) — Task 6 |
| `src/examples/capability-offline-demo.ts` | Capability demo (offline) — Task 6, new file |
| `schemas/trust-profile.schema.json` | Trust schema — Task 0 |
| `schemas/capability-offering.schema.json` | Offering schema — reference for Task 2 |
| `schemas/need.schema.json` | Need schema — reference for Task 2 |
| `schemas/protocol-messages.schema.json` | Protocol messages — reference for Task 5 |
| `PHILOSOPHY.md` | Project philosophy — check tone/framing |

## Verification commands

```bash
npm run build              # TypeScript compiles cleanly
npm run validate           # Schemas valid
npm run validate:examples  # Example data valid
npm run trust              # Trust demo runs
npm run match              # Match demo runs
npm run trace              # Trace demo runs
npm run capability         # Capability demo runs (offline)
```

## Start

Read the plan at `docs/plans/2026-02-27-demo-enrichment-plan.md`, then begin with Task 0.
