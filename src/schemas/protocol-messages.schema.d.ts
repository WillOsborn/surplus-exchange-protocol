/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Message formats for communication between participants, agents, and brokers in the Surplus Exchange Protocol. All messages follow a common header structure with type-specific payloads.
 */
export type SEPProtocolMessages =
  | ChainProposal
  | ParticipantConfirmation
  | ChainCommitment
  | ExecutionStart
  | ExecutionCompletion
  | SatisfactionSignal
  | DisputeRaised
  | ChainCompletion
  | ChainFailure
  | MessageAcknowledgment
  | HealthCheck;
/**
 * Proposes a new exchange chain to potential participants. Sent by a broker or matching algorithm when a viable chain has been identified.
 */
export type ChainProposal = MessageHeader & {
  message_type?: "ChainProposal";
  /**
   * Unique identifier for this proposed chain
   */
  chain_id: string;
  /**
   * The exchanges that comprise this chain (minimum 2 for a valid cycle)
   *
   * @minItems 2
   */
  edges: [EdgeReference, EdgeReference, ...EdgeReference[]];
  timing: TimingConstraints;
  match_rationale: MatchRationale;
  /**
   * Additional metadata about the proposed chain
   */
  metadata?: {
    /**
     * How this chain was identified
     */
    proposed_by?: "algorithm" | "participant" | "broker";
    /**
     * Whether any edge involves physical goods requiring logistics
     */
    includes_physical_goods?: boolean;
    /**
     * Geographic regions involved in this chain
     */
    geographic_span?: string[];
    [k: string]: unknown;
  };
  [k: string]: unknown;
};
/**
 * A participant's response to a chain proposal. Can confirm, decline, or propose modifications.
 */
export type ParticipantConfirmation = MessageHeader & {
  message_type?: "ParticipantConfirmation";
  /**
   * Chain this confirmation relates to
   */
  chain_id: string;
  /**
   * Identifier of the confirming participant
   */
  participant_id: string;
  /**
   * Participant's decision on the proposal
   */
  decision: "confirm" | "decline" | "counter";
  /**
   * Conditions attached to a confirmation (must be agreed by other parties)
   */
  conditions?: string[];
  /**
   * Explanation for declining (required when decision is 'decline')
   */
  decline_reason?: string;
  /**
   * Proposed modifications when decision is 'counter'
   */
  counter_proposal?: {
    timing_adjustment?: TimingConstraints1;
    /**
     * Proposed changes to specific edges
     */
    edge_modifications?: {
      /**
       * Edge to modify
       */
      edge_id: string;
      /**
       * Description of proposed modification
       */
      modification: string;
      [k: string]: unknown;
    }[];
    [k: string]: unknown;
  };
  [k: string]: unknown;
};
/**
 * Notification that all participants have confirmed and the chain is now binding. Marks transition from 'confirming' to 'committed' status.
 */
export type ChainCommitment = MessageHeader & {
  message_type?: "ChainCommitment";
  /**
   * Chain that is now committed
   */
  chain_id: string;
  /**
   * All edges with their confirmation timestamps
   *
   * @minItems 2
   */
  confirmed_edges: [ConfirmedEdge, ConfirmedEdge, ...ConfirmedEdge[]];
  final_timing: TimingConstraints2;
  /**
   * Cryptographic hash of the committed chain state (format: algorithm:hash)
   */
  commitment_hash: string;
  /**
   * Summary of each participant's role in the chain
   */
  participants_summary?: ParticipantSummary[];
  [k: string]: unknown;
};
/**
 * Provider signals they have begun executing their edge of the exchange.
 */
export type ExecutionStart = MessageHeader & {
  message_type?: "ExecutionStart";
  /**
   * Chain this execution belongs to
   */
  chain_id: string;
  /**
   * Edge being executed
   */
  edge_id: string;
  /**
   * When execution began
   */
  started_at: string;
  /**
   * Provider's estimated completion date
   */
  expected_completion?: string;
  /**
   * Optional notes about the execution plan or approach
   */
  notes?: string;
  [k: string]: unknown;
};
/**
 * Provider signals they have completed delivery of their offering.
 */
export type ExecutionCompletion = MessageHeader & {
  message_type?: "ExecutionCompletion";
  /**
   * Chain this completion belongs to
   */
  chain_id: string;
  /**
   * Edge that was completed
   */
  edge_id: string;
  /**
   * When delivery was completed
   */
  completed_at: string;
  delivery_evidence?: DeliveryEvidence;
  /**
   * Additional notes about the delivery
   */
  notes?: string;
  [k: string]: unknown;
};
/**
 * Recipient's subjective assessment of the delivery quality. Core to the subjective value ledger concept.
 */
export type SatisfactionSignal = MessageHeader & {
  message_type?: "SatisfactionSignal";
  /**
   * Chain this signal relates to
   */
  chain_id: string;
  /**
   * Edge being assessed
   */
  edge_id: string;
  signal: SatisfactionLevel;
  /**
   * Optional qualitative feedback about the exchange
   */
  feedback?: string;
  /**
   * Detailed breakdown when signal is 'partially_satisfied'
   */
  partial_satisfaction_details?: {
    /**
     * Aspects of the delivery that met expectations
     */
    what_was_good?: string;
    /**
     * Aspects that fell short of expectations
     */
    what_was_missing?: string;
    /**
     * What would make the recipient fully satisfied
     */
    suggested_resolution?: string;
    [k: string]: unknown;
  };
  [k: string]: unknown;
};
/**
 * Participant's satisfaction level
 */
export type SatisfactionLevel = "satisfied" | "partially_satisfied" | "not_satisfied";
/**
 * Initiates a formal dispute about an edge, triggering the dispute resolution process.
 */
export type DisputeRaised = MessageHeader & {
  message_type?: "DisputeRaised";
  /**
   * Chain containing the disputed edge
   */
  chain_id: string;
  /**
   * Edge being disputed
   */
  edge_id: string;
  dispute_type: DisputeType;
  /**
   * Detailed description of the dispute and circumstances
   */
  description: string;
  /**
   * Evidence supporting the dispute
   */
  evidence?: {
    /**
     * Type of evidence
     */
    evidence_type: string;
    /**
     * Description of the evidence
     */
    description: string;
    /**
     * URL to access the evidence
     */
    url?: string;
    [k: string]: unknown;
  }[];
  /**
   * What outcome the disputing party is seeking
   */
  requested_resolution?: string;
  /**
   * Whether the party is open to third-party mediation
   */
  willing_to_mediate?: boolean;
  [k: string]: unknown;
};
/**
 * Category of dispute
 */
export type DisputeType =
  | "non_delivery"
  | "partial_delivery"
  | "quality_mismatch"
  | "timing_violation"
  | "scope_dispute"
  | "other";
/**
 * Notification that all edges have been satisfied and the chain is complete. Triggers trust metric updates.
 */
export type ChainCompletion = MessageHeader & {
  message_type?: "ChainCompletion";
  /**
   * Chain that completed
   */
  chain_id: string;
  /**
   * When the final edge was satisfied
   */
  completed_at: string;
  /**
   * Summary statistics for the completed chain
   */
  summary: {
    /**
     * Total number of edges in the chain
     */
    total_edges: number;
    /**
     * Number of edges with 'satisfied' signal
     */
    satisfied_edges: number;
    /**
     * Number of edges with 'partially_satisfied' signal
     */
    partially_satisfied_edges?: number;
    /**
     * Days from first execution start to final satisfaction
     */
    execution_duration_days?: number;
    /**
     * Whether all edges completed within their scheduled windows
     */
    within_schedule?: boolean;
    [k: string]: unknown;
  };
  /**
   * Summary of trust metric changes resulting from this chain
   */
  trust_updates?: {
    /**
     * Participant whose trust metrics were updated
     */
    participant_id: string;
    /**
     * Direction of trust update
     */
    update_type: "positive" | "neutral" | "negative";
    [k: string]: unknown;
  }[];
  [k: string]: unknown;
};
/**
 * Notification that a chain has failed, including compensation and resolution information.
 */
export type ChainFailure = MessageHeader & {
  message_type?: "ChainFailure";
  /**
   * Chain that failed
   */
  chain_id: string;
  /**
   * When the failure was determined
   */
  failed_at: string;
  failure_reason: FailureReason;
  /**
   * Edge that triggered the failure, if applicable
   */
  failed_edge_id?: string;
  /**
   * Status and compensation action for each edge
   */
  affected_edges?: AffectedEdge[];
  /**
   * Plan for compensating affected participants
   */
  compensation_plan?: {
    /**
     * Overall compensation strategy
     */
    strategy?: "restructure" | "partial_complete" | "full_unwind" | "settle_externally";
    /**
     * Specific actions to be taken
     */
    actions?: string[];
    /**
     * Whether participants must approve the compensation plan
     */
    requires_approval?: boolean;
    [k: string]: unknown;
  };
  [k: string]: unknown;
};
/**
 * Category of failure
 */
export type FailureReason =
  | "edge_timeout"
  | "edge_abandonment"
  | "unresolved_dispute"
  | "participant_withdrawal"
  | "cascade_failure"
  | "infrastructure_failure"
  | "other";
/**
 * Acknowledges receipt and processing of a message. Used for delivery confirmation and error reporting.
 */
export type MessageAcknowledgment = MessageHeader & {
  message_type?: "MessageAcknowledgment";
  /**
   * ID of the message being acknowledged
   */
  original_message_id: string;
  /**
   * When the original message was received
   */
  received_at: string;
  processing_status: ProcessingStatus;
  /**
   * Human-readable explanation for rejection
   */
  rejection_reason?: string;
  rejection_code?: RejectionCode;
  [k: string]: unknown;
};
/**
 * Status of processing the original message
 */
export type ProcessingStatus = "accepted" | "rejected" | "pending";
/**
 * Standardised code for rejection reason
 */
export type RejectionCode =
  | "invalid_format"
  | "invalid_chain_id"
  | "invalid_participant"
  | "invalid_state_transition"
  | "expired"
  | "duplicate"
  | "unauthorized"
  | "other";
/**
 * Periodic health check message for monitoring chain progress and identifying issues.
 */
export type HealthCheck = MessageHeader & {
  message_type?: "HealthCheck";
  /**
   * Chain being monitored
   */
  chain_id: string;
  /**
   * What initiated this health check
   */
  check_type: "scheduled" | "triggered" | "manual";
  status: HealthStatus;
  /**
   * Numeric health score (0 = critical, 1 = perfect)
   */
  health_score?: number;
  /**
   * Health status of each edge in the chain
   */
  edge_statuses?: EdgeHealthStatus[];
  /**
   * Identified issues requiring attention
   */
  issues?: HealthIssue[];
  /**
   * Suggested actions to address issues
   */
  recommendations?: string[];
  [k: string]: unknown;
};
/**
 * Overall health assessment
 */
export type HealthStatus = "healthy" | "warning" | "at_risk" | "failing";
/**
 * Severity level for health check issues
 */
export type IssueSeverity = "info" | "warning" | "critical";

/**
 * Common header fields present in all SEP protocol messages. Provides identification, routing, and integrity verification.
 */
export interface MessageHeader {
  /**
   * Unique identifier for this message, used for idempotency and deduplication
   */
  message_id: string;
  /**
   * Discriminator field identifying the message type
   */
  message_type: string;
  /**
   * ISO 8601 timestamp of when the message was created
   */
  timestamp: string;
  /**
   * Identifier of the sending participant, agent, or broker
   */
  sender_id: string;
  /**
   * SEP protocol version (major.minor format, e.g., '1.0')
   */
  protocol_version: string;
  /**
   * Optional identifier linking related messages in a conversation or workflow
   */
  correlation_id?: string;
  /**
   * Message ID this is a direct response to
   */
  reply_to?: string;
  /**
   * Ed25519 or similar cryptographic signature of message content for integrity verification
   */
  signature?: string;
  [k: string]: unknown;
}
/**
 * Reference to a single exchange edge within a chain, identifying provider, recipient, and the offering being exchanged
 */
export interface EdgeReference {
  /**
   * Unique identifier for this edge within the chain
   */
  edge_id: string;
  /**
   * Participant providing the offering
   */
  provider_id: string;
  /**
   * Participant receiving the offering
   */
  recipient_id: string;
  /**
   * Reference to the capability offering being exchanged
   */
  offering_id: string;
  /**
   * Human-readable summary of the offering for quick comprehension
   */
  offering_summary?: string;
  [k: string]: unknown;
}
/**
 * Proposed timing for confirmation and execution
 */
export interface TimingConstraints {
  /**
   * Deadline by which all participants must confirm their participation
   */
  confirmation_deadline?: string;
  /**
   * The time period during which exchanges must be executed
   */
  execution_window?: {
    /**
     * Earliest date when execution can begin
     */
    start: string;
    /**
     * Latest date by which all exchanges must be complete
     */
    end: string;
    [k: string]: unknown;
  };
  /**
   * Specific timing constraints for individual edges
   */
  edge_schedules?: {
    /**
     * Reference to the edge these constraints apply to
     */
    edge_id: string;
    /**
     * Earliest date this edge can begin execution
     */
    earliest_start?: string;
    /**
     * Latest date this edge must be completed
     */
    latest_completion?: string;
    [k: string]: unknown;
  }[];
  [k: string]: unknown;
}
/**
 * Explanation of why this chain was proposed
 */
export interface MatchRationale {
  /**
   * Version of the matching algorithm that identified this chain
   */
  algorithm_version?: string;
  /**
   * Confidence score (0-1) indicating quality of the match
   */
  match_score?: number;
  /**
   * Human-readable explanations of the key matches identified
   */
  key_matches?: string[];
  [k: string]: unknown;
}
/**
 * Proposed changes to timing
 */
export interface TimingConstraints1 {
  /**
   * Deadline by which all participants must confirm their participation
   */
  confirmation_deadline?: string;
  /**
   * The time period during which exchanges must be executed
   */
  execution_window?: {
    /**
     * Earliest date when execution can begin
     */
    start: string;
    /**
     * Latest date by which all exchanges must be complete
     */
    end: string;
    [k: string]: unknown;
  };
  /**
   * Specific timing constraints for individual edges
   */
  edge_schedules?: {
    /**
     * Reference to the edge these constraints apply to
     */
    edge_id: string;
    /**
     * Earliest date this edge can begin execution
     */
    earliest_start?: string;
    /**
     * Latest date this edge must be completed
     */
    latest_completion?: string;
    [k: string]: unknown;
  }[];
  [k: string]: unknown;
}
/**
 * Edge confirmation status with timestamps
 */
export interface ConfirmedEdge {
  /**
   * Reference to the confirmed edge
   */
  edge_id: string;
  /**
   * When the provider confirmed their participation
   */
  provider_confirmed_at?: string;
  /**
   * When the recipient confirmed their participation
   */
  recipient_confirmed_at?: string;
  [k: string]: unknown;
}
/**
 * Agreed timing constraints after any negotiation
 */
export interface TimingConstraints2 {
  /**
   * Deadline by which all participants must confirm their participation
   */
  confirmation_deadline?: string;
  /**
   * The time period during which exchanges must be executed
   */
  execution_window?: {
    /**
     * Earliest date when execution can begin
     */
    start: string;
    /**
     * Latest date by which all exchanges must be complete
     */
    end: string;
    [k: string]: unknown;
  };
  /**
   * Specific timing constraints for individual edges
   */
  edge_schedules?: {
    /**
     * Reference to the edge these constraints apply to
     */
    edge_id: string;
    /**
     * Earliest date this edge can begin execution
     */
    earliest_start?: string;
    /**
     * Latest date this edge must be completed
     */
    latest_completion?: string;
    [k: string]: unknown;
  }[];
  [k: string]: unknown;
}
/**
 * Summary of a participant's role in the chain
 */
export interface ParticipantSummary {
  /**
   * Identifier of the participant
   */
  participant_id: string;
  /**
   * Participant they are providing to
   */
  provides_to?: string;
  /**
   * Participant they receive from
   */
  receives_from?: string;
  [k: string]: unknown;
}
/**
 * Evidence supporting the completion claim
 */
export interface DeliveryEvidence {
  /**
   * Category of evidence provided
   */
  evidence_type?: "document" | "confirmation" | "tracking" | "photo" | "other";
  /**
   * Human-readable description of the evidence
   */
  description?: string;
  /**
   * File attachments supporting the claim
   */
  attachments?: {
    /**
     * Name of the attached file
     */
    filename: string;
    /**
     * URL where the attachment can be retrieved
     */
    url: string;
    /**
     * Cryptographic hash (SHA-256) of file contents for integrity verification
     */
    hash?: string;
    [k: string]: unknown;
  }[];
  [k: string]: unknown;
}
/**
 * Edge status and compensation action when a chain fails
 */
export interface AffectedEdge {
  /**
   * Reference to the affected edge
   */
  edge_id: string;
  /**
   * Edge status at the time of chain failure
   */
  status_at_failure: string;
  /**
   * Action taken to compensate or resolve this edge
   */
  compensation_action: "completed_independently" | "reversed" | "compensated" | "none_required";
  [k: string]: unknown;
}
/**
 * Health status of an individual edge during monitoring
 */
export interface EdgeHealthStatus {
  /**
   * Reference to the edge
   */
  edge_id: string;
  /**
   * Current execution status of the edge
   */
  status: string;
  /**
   * Estimated percentage completion (0-100)
   */
  progress_percent?: number;
  /**
   * Whether the edge is progressing according to schedule
   */
  on_schedule?: boolean;
  [k: string]: unknown;
}
/**
 * An identified issue during health monitoring
 */
export interface HealthIssue {
  /**
   * Category of issue identified
   */
  issue_type: string;
  severity: IssueSeverity;
  /**
   * Human-readable description of the issue
   */
  description: string;
  /**
   * Edge affected by this issue, if applicable
   */
  affected_edge_id?: string;
  [k: string]: unknown;
}
